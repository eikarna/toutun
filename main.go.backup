package main

import (
	"bufio"
	"context"
	"crypto/tls"
	"encoding/json"
	"flag"
	"io"
	"log"
	"net"
	"os"
	"strings"
	"sync/atomic"
	"time"

	quic "github.com/quic-go/quic-go"
	"github.com/things-go/go-socks5"
)

// Config adalah struktur konfigurasi yang diambil dari file JSON.
type Config struct {
	Mode               string `json:"mode"`
	QUICAddr           string `json:"quic_addr"`
	TLSCertFile        string `json:"tls_cert_file"`
	TLSKeyFile         string `json:"tls_key_file"`
	SocksAddr          string `json:"socks_addr"`
	LogLevel           string `json:"log_level"`
	IdleTimeoutSeconds int    `json:"idle_timeout_seconds"`
}

var config Config

const (
	LogLevelDebug = "debug"
	LogLevelInfo  = "info"
	LogLevelWarn  = "warn"
	LogLevelError = "error"
)

var logLevel = LogLevelInfo

func logf(level string, format string, v ...interface{}) {
	allowed := map[string]int{
		LogLevelDebug: 0,
		LogLevelInfo:  1,
		LogLevelWarn:  2,
		LogLevelError: 3,
	}
	if allowed[level] >= allowed[logLevel] {
		log.Printf("[%s] "+format, append([]interface{}{strings.ToUpper(level)}, v...)...)
	}
}

var (
	totalConn   int64
	activeConn  int64
	successConn int64
	errorConn   int64
)

func main() {
	configFile := flag.String("config", "config.json", "Path ke file konfigurasi JSON")
	flag.Parse()

	file, err := os.Open(*configFile)
	if err != nil {
		log.Fatalf("Gagal membuka file konfigurasi: %v", err)
	}
	defer file.Close()

	if err := json.NewDecoder(file).Decode(&config); err != nil {
		log.Fatalf("Gagal decode konfigurasi: %v", err)
	}
	logLevel = strings.ToLower(config.LogLevel)

	switch strings.ToLower(config.Mode) {
	case "server":
		runServer(&config)
	case "client":
		runClient(&config)
	default:
		log.Fatalf("Mode tidak valid: %s", config.Mode)
	}

}

func runServer(cfg *Config) {
	tlsCert, err := tls.LoadX509KeyPair(cfg.TLSCertFile, cfg.TLSKeyFile)
	if err != nil {
		log.Fatalf("Gagal load sertifikat TLS: %v", err)
	}
	tlsConfig := &tls.Config{
		Certificates: []tls.Certificate{tlsCert},
		NextProtos:   []string{"quic-tunnel"},
	}

	listener, err := quic.ListenAddr(cfg.QUICAddr, tlsConfig, nil)
	if err != nil {
		log.Fatalf("Gagal listen pada %s: %v", cfg.QUICAddr, err)
	}
	logf("info", "Server QUIC mendengarkan pada %s", cfg.QUICAddr)

	go func() {
		ticker := time.NewTicker(10 * time.Second)
		defer ticker.Stop()
		for range ticker.C {
			logf("info", "Stats - Total: %d | Aktif: %d | Sukses: %d | Error: %d",
				atomic.LoadInt64(&totalConn),
				atomic.LoadInt64(&activeConn),
				atomic.LoadInt64(&successConn),
				atomic.LoadInt64(&errorConn))
		}
	}()

	for {
		conn, err := listener.Accept(context.Background())
		if err != nil {
			logf("error", "Gagal menerima connection: %v", err)
			continue
		}
		go handleQUICConnection(conn)
	}

}

func handleQUICConnection(conn quic.Connection) {
	defer conn.CloseWithError(0, "menutup connection")
	for {
		stream, err := conn.AcceptStream(context.Background())
		if err != nil {
			logf("error", "Gagal menerima stream: %v", err)
			return
		}
		go handleStream(stream)
	}
}

func handleStream(stream quic.Stream) {
	atomic.AddInt64(&totalConn, 1)
	atomic.AddInt64(&activeConn, 1)
	defer atomic.AddInt64(&activeConn, -1)
	defer stream.Close()

	reader := bufio.NewReader(stream)
	targetLine, err := reader.ReadString('\n')
	if err != nil {
		atomic.AddInt64(&errorConn, 1)
		logf("error", "Gagal membaca alamat tujuan: %v", err)
		return
	}
	target := strings.TrimSpace(targetLine)
	if _, _, err := net.SplitHostPort(target); err != nil {
		atomic.AddInt64(&errorConn, 1)
		logf("error", "Alamat target tidak valid: %q (%v)", target, err)
		return
	}

	logf("info", "Meneruskan koneksi ke %s", target)

	tcpConn, err := net.Dial("tcp", target)
	if err != nil {
		atomic.AddInt64(&errorConn, 1)
		logf("error", "Gagal menghubungkan ke %s: %v", target, err)
		return
	}
	defer tcpConn.Close()
	atomic.AddInt64(&successConn, 1)

	deadline := time.Now().Add(time.Duration(config.IdleTimeoutSeconds) * time.Second)
	_ = stream.SetDeadline(deadline)
	_ = tcpConn.SetDeadline(deadline)

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	go func() {
		_, err := io.Copy(tcpConn, reader)
		if err != nil {
			logf("debug", "QUIC → TCP error: %v", err)
		}
		cancel()
	}()
	go func() {
		_, err := io.Copy(stream, tcpConn)
		if err != nil {
			logf("debug", "TCP → QUIC error: %v", err)
		}
		cancel()
	}()

	<-ctx.Done()
	logf("debug", "Selesai koneksi ke %s", target)

}

func runClient(cfg *Config) {
	dialer := &QUICDialer{quicAddr: cfg.QUICAddr}

	socksServer := socks5.NewServer(socks5.WithDial(dialer.Dial))

	log.Printf("Client SOCKS5 mendengarkan pada %s", cfg.SocksAddr)
	if err := socksServer.ListenAndServe("tcp", cfg.SocksAddr); err != nil {
		log.Fatalf("Error menjalankan SOCKS5 server: %v", err)
	}
}

// QUICDialer digunakan oleh SOCKS5 server untuk membuat koneksi tunnel ke server QUIC.
type QUICDialer struct{ quicAddr string }

func (d *QUICDialer) Dial(ctx context.Context, network, addr string) (net.Conn, error) {
	tlsConfig := &tls.Config{InsecureSkipVerify: true, NextProtos: []string{"quic-tunnel"}}

	conn, err := quic.DialAddr(context.Background(), d.quicAddr, tlsConfig, nil)
	if err != nil {
		return nil, err
	}

	stream, err := conn.OpenStreamSync(ctx)
	if err != nil {
		conn.CloseWithError(0, "gagal membuka stream")
		return nil, err
	}

	_, err = stream.Write([]byte(addr + "\n"))
	if err != nil {
		stream.Close()
		return nil, err
	}

	return &quicStreamConn{
		Stream: stream,
		sess:   conn,
	}, nil

}

type quicStreamConn struct {
	quic.Stream
	sess quic.Connection
}

func (c *quicStreamConn) LocalAddr() net.Addr {
	addr := c.sess.LocalAddr().(*net.UDPAddr)
	return &net.TCPAddr{IP: addr.IP, Port: addr.Port, Zone: ""}
}

func (c *quicStreamConn) Close() error {
	err := c.Stream.Close()
	c.sess.CloseWithError(0, "menutup connection")
	return err
}

func (c *quicStreamConn) RemoteAddr() net.Addr {
	return c.sess.RemoteAddr()
}

func (c *quicStreamConn) SetDeadline(t time.Time) error {
	return c.Stream.SetDeadline(t)
}

func (c *quicStreamConn) SetReadDeadline(t time.Time) error {
	return c.Stream.SetReadDeadline(t)
}

func (c *quicStreamConn) SetWriteDeadline(t time.Time) error {
	return c.Stream.SetWriteDeadline(t)
}
